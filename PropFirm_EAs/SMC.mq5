//+------------------------------------------------------------------+
//|                                                PropFirmEA.mq5    |
//|                        Generated by ChatGPT                      |
//+------------------------------------------------------------------+
#property strict

// Parameters for prop firm rules
input double DailyDrawdownLimit = 5.0; // Max daily drawdown percentage
input double MaxDrawdownLimit = 10.0; // Max overall drawdown percentage
input bool AvoidNewsTrading = true;   // Disable trading during news events

// Strategy parameters (Smart Money Concept & ICT)
input double RiskPerTrade = 1.0;      // Risk per trade as a percentage of equity
input int Timeframe = PERIOD_H1;      // Trading timeframe
input double StopLossBuffer = 2.0;    // Stop-loss buffer in pips
input double TakeProfitRatio = 3.0;   // Reward to risk ratio
input bool EnableTrailingStop = true; // Enable trailing stop
input double OrderBlockBuffer = 2.0;  // Buffer for order block zones in pips
input bool UseVolumeAnalysis = true;  // Enable volume analysis
input string TradingSessions = "London,NewYork"; // Allowed trading sessions

// Global variables
double AccountInitialBalance;
int LastTradeDay = 0;

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
   AccountInitialBalance = AccountInfoDouble(ACCOUNT_BALANCE);
   LastTradeDay = TimeDay(TimeCurrent());
   return(INIT_SUCCEEDED);
  }

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
   // Placeholder for cleanup code
  }

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
  {
   // Check for daily drawdown
   if (ExceedsDailyDrawdown()) return;

   // Check for max drawdown
   if (ExceedsMaxDrawdown()) return;

   // Avoid trading during news events
   if (AvoidNewsTrading && IsNewsTime()) return;

   // Restrict trading to specific sessions
   if (!IsAllowedSession()) return;

   // Analyze the market and place trades
   TradeStrategy();
  }

//+------------------------------------------------------------------+
//| Check for daily drawdown                                         |
//+------------------------------------------------------------------+
bool ExceedsDailyDrawdown()
  {
   double dailyLoss = AccountInitialBalance - AccountInfoDouble(ACCOUNT_BALANCE);
   double dailyLossPercentage = (dailyLoss / AccountInitialBalance) * 100.0;

   if (dailyLossPercentage > DailyDrawdownLimit)
     {
      Print("Daily drawdown limit exceeded. Trading halted for the day.");
      return true;
     }
   return false;
  }

//+------------------------------------------------------------------+
//| Check for max drawdown                                           |
//+------------------------------------------------------------------+
bool ExceedsMaxDrawdown()
  {
   double totalLoss = AccountInitialBalance - AccountInfoDouble(ACCOUNT_BALANCE);
   double totalLossPercentage = (totalLoss / AccountInitialBalance) * 100.0;

   if (totalLossPercentage > MaxDrawdownLimit)
     {
      Print("Max drawdown limit exceeded. Trading halted.");
      return true;
     }
   return false;
  }

//+------------------------------------------------------------------+
//| Placeholder for news detection                                   |
//+------------------------------------------------------------------+
bool IsNewsTime()
  {
   // Implement news detection logic using external sources or EA input
   return false;
  }

//+------------------------------------------------------------------+
//| Check if trading is allowed in the current session               |
//+------------------------------------------------------------------+
bool IsAllowedSession()
  {
   string currentSession = GetCurrentSession();
   return (StringFind(TradingSessions, currentSession) >= 0);
  }

//+------------------------------------------------------------------+
//| Get current trading session                                      |
//+------------------------------------------------------------------+
string GetCurrentSession()
  {
   datetime now = TimeCurrent();
   int hour = TimeHour(now);

   if (hour >= 7 && hour <= 16) return "London";
   if (hour >= 13 && hour <= 22) return "NewYork";

   return "Other";
  }

//+------------------------------------------------------------------+
//| Strategy implementation                                          |
//+------------------------------------------------------------------+
void TradeStrategy()
  {
   // Analyze Smart Money Concept (SMC) and ICT concepts here
   double entryPrice, stopLoss, takeProfit;

   if (FindTradeSetup(entryPrice, stopLoss, takeProfit))
     {
      double lotSize = CalculateLotSize(stopLoss);
      if (lotSize > 0)
        PlaceTrade(entryPrice, stopLoss, takeProfit, lotSize);
     }
  }

//+------------------------------------------------------------------+
//| Identify trade setup based on SMC and ICT                        |
//+------------------------------------------------------------------+
bool FindTradeSetup(double &entryPrice, double &stopLoss, double &takeProfit)
  {
   // Retrieve historical data
   double high = iHigh(Symbol(), Timeframe, 1);
   double low = iLow(Symbol(), Timeframe, 1);
   double close = iClose(Symbol(), Timeframe, 1);
   double open = iOpen(Symbol(), Timeframe, 1);

   // Define key levels
   double rangeHigh = high;
   double rangeLow = low;
   double equilibrium = (rangeHigh + rangeLow) / 2.0;

   // Identify order blocks
   double orderBlockHigh = high + (OrderBlockBuffer * Point);
   double orderBlockLow = low - (OrderBlockBuffer * Point);

   // Identify fair value gaps (FVG)
   double fvgLow = MathMin(iHigh(Symbol(), Timeframe, 2), iLow(Symbol(), Timeframe, 2));
   double fvgHigh = MathMax(iHigh(Symbol(), Timeframe, 2), iLow(Symbol(), Timeframe, 2));

   // Check for liquidity sweep and break of structure
   double currentHigh = iHigh(Symbol(), Timeframe, 0);
   double currentLow = iLow(Symbol(), Timeframe, 0);

   bool liquiditySweep = (currentHigh > rangeHigh || currentLow < rangeLow);
   bool breakOfStructure = (close > equilibrium || close < equilibrium);

   // Optional: Integrate volume analysis
   bool isHighVolume = UseVolumeAnalysis && (iVolume(Symbol(), Timeframe, 0) > iVolume(Symbol(), Timeframe, 1));

   if (liquiditySweep && breakOfStructure && isHighVolume)
     {
      // Determine trade direction
      bool isBuy = (close > equilibrium);
      bool isSell = (close < equilibrium);

      if (isBuy && close > orderBlockHigh && close < fvgHigh)
        {
         entryPrice = close;
         stopLoss = rangeLow - (StopLossBuffer * Point);
         takeProfit = entryPrice + (TakeProfitRatio * (entryPrice - stopLoss));
         return true;
        }
      else if (isSell && close < orderBlockLow && close > fvgLow)
        {
         entryPrice = close;
         stopLoss = rangeHigh + (StopLossBuffer * Point);
         takeProfit = entryPrice - (TakeProfitRatio * (stopLoss - entryPrice));
         return true;
        }
     }

   return false;
  }

//+------------------------------------------------------------------+
//| Calculate lot size based on risk                                 |
//+------------------------------------------------------------------+
double CalculateLotSize(double stopLoss)
  {
   double equity = AccountInfoDouble(ACCOUNT_EQUITY);
   double riskAmount = (RiskPerTrade / 100.0) * equity;
   double pipValue = MarketInfo(Symbol(), MODE_TICKVALUE);

   double lotSize = riskAmount / (stopLoss * pipValue);
   return NormalizeDouble(lotSize, 2);
  }

//+------------------------------------------------------------------+
//| Place trade                                                      |
//+------------------------------------------------------------------+
void PlaceTrade(double entryPrice, double stopLoss, double takeProfit, double lotSize)
  {
   int ticket = OrderSend(Symbol(), OP_BUY, lotSize, entryPrice, 3, stopLoss, takeProfit, "SMC Trade", 0, 0, Green);

   if (ticket > 0)
     {
      Print("Trade placed successfully. Ticket: ", ticket);
     }
   else
     {
      Print("Error placing trade: ", GetLastError());
     }
  }
